;; -*- mode: scheme; -*-
;; Why We Love Wasps Copyright (C) 2019 FoAM Kernow
;;
;; This program is free software: you can redistribute it and/or modify
;; it under the terms of the GNU Affero General Public License as
;; published by the Free Software Foundation, either version 3 of the
;; License, or (at your option) any later version.
;;
;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU Affero General Public License for more details.
;;
;; You should have received a copy of the GNU Affero General Public License
;; along with this program.  If not, see <http://www.gnu.org/licenses/>.

(define cell-code-unbuilt 0)
(define cell-code-empty 1)
(define cell-code-occupied 2)

(define cell-size-x 18)
(define cell-size-y 7)

(define (make-cell pos logical code img) (list pos logical code img))
(define (cell-pos c) (list-ref c 0))
(define (cell-logical c) (list-ref c 1))
(define (cell-code c) (list-ref c 2))
(define (cell-modify-code c v) (list-replace c 2 v))
(define (cell-img c) (list-ref c 3))

(define (generate-cells w h)
  (foldl
   (lambda (c r)
     (append r c))
   '()
   (build-list
    h (lambda (y)     
	(build-list
	 w (lambda (x)
	     (make-cell 
	      (vec2 (+ (* x 60) 100)
		    (+ (* y 75) 150 
		       (if (zero? (modulo x 2)) 37 0)))
	      (vec2 x y)
	      (if (and (eq? x 9) (eq? y 3))
		  cell-code-empty
		  cell-code-unbuilt)
	      (choose
	       (list
		(find-image "sprites/hex-1.png")
		(find-image "sprites/hex-2.png")
		(find-image "sprites/hex-3.png")
		(find-image "sprites/hex-4.png")
		)))))))))

(define (cell-pos->index pos)
  (+ (min (- cell-size-x 1) (vx pos))
     (* (min (- cell-size-y 1) (vy pos)) cell-size-x)))

(define (cell-nindexes cell)
  (let ((x (vx (cell-logical cell)))
	(y (vy (cell-logical cell))))
    ;; bloomin hexagons...
    (append
     (list
      (cell-pos->index (vec2 x (+ y 1)))
      (cell-pos->index (vec2 x (- y 1)))
      (cell-pos->index (vec2 (+ x 1) y))
      (cell-pos->index (vec2 (- x 1) y)))
     (if (zero? (modulo x 2))
     	 (list
     	  (cell-pos->index (vec2 (+ x 1) (+ y 1)))
     	  (cell-pos->index (vec2 (- x 1) (+ y 1))))
     	 (list
     	  (cell-pos->index (vec2 (+ x 1) (- y 1)))
     	  (cell-pos->index (vec2 (- x 1) (- y 1)))))
     ))))
